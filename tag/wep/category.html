<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ØªØµÙ†ÙŠÙ Ø§Ù„Ø£Ù†Ù…ÙŠ</title>
  <link rel="stylesheet" href="../../CSS/style.css" />
  <script src="../../navbar.js" defer></script>
  <link rel="icon" href="https://abdo12249.github.io/1/navbar/favicon.ico" type="image/x-icon" />
  
</head>
<body>
  <!-- Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ†Ù‚Ù„ -->
  <div id="navbar-container"></div>

  <main>
    <div class="section-header">
      <h1 id="category-title">Ø§Ù„ØªØµÙ†ÙŠÙ</h1>
    </div>

    <!-- Ø´Ø¨ÙƒØ© Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª -->
    <div class="anime-grid" id="animeGrid"></div>
  </main>

  <!-- Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ...</span>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const category = urlParams.get('category');

    document.getElementById("category-title").textContent = category
      ? "ØªØµÙ†ÙŠÙ: " + category
      : "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª";

    let allAnimes = []; // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª Ø¨Ø¹Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±
    const cacheDuration = 24 * 60 * 60 * 1000; // 24 Ø³Ø§Ø¹Ø© Ø¨Ø§Ù„Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©

    // Ø«ÙˆØ§Ø¨Øª IndexedDB
    const DB_NAME = 'AnimeCategoriesDB'; // Ø§Ø³Ù… Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø®ØªÙ„ÙØ© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¹Ø§Ø±Ø¶
    const DB_VERSION = 1;
    const STORE_NAME = 'animeDataCache';
    const CACHE_KEY = 'cachedAnimeCategories';

    let db; // Ù…ØªØºÙŠØ± Ù„Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ù†Ø³Ø®Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª IndexedDB

    // Ø¯Ø§Ù„Ø© Ù„ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª IndexedDB
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME);
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };

        request.onerror = (event) => {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† IndexedDB
    async function readFromIndexedDB(key) {
      if (!db) {
        await openDatabase();
      }
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(key);

        request.onsuccess = (event) => {
          resolve(event.target.result);
        };

        request.onerror = (event) => {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ IndexedDB
    async function writeToIndexedDB(key, data) {
      if (!db) {
        await openDatabase();
      }
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(data, key);

        request.onsuccess = () => {
          resolve();
        };

        request.onerror = (event) => {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ÙƒØªØ§Ø¨Ø© IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
    function showLoading() {
      document.getElementById('loadingOverlay').style.display = 'flex';
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø®ÙØ§Ø¡ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
    function hideLoading() {
      document.getElementById('loadingOverlay').style.display = 'none';
    }

    async function loadAnimes() {
      showLoading(); // Ø¥Ø¸Ù‡Ø§Ø± Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
      try {
        await openDatabase(); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙØªØ­ IndexedDB

        const cachedObject = await readFromIndexedDB(CACHE_KEY);
        const now = Date.now();

        if (cachedObject && cachedObject.animes && (now - cachedObject.timestamp) < cacheDuration) {
          // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªÙ‹Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø© ÙˆØµØ§Ù„Ø­Ø©
          allAnimes = cachedObject.animes;
          console.log("âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ Ù…Ù† IndexedDB.");
        } else {
          // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© Ø£Ùˆ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØªÙ‡Ø§
          console.log("ğŸ”„ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ Ø¬Ø¯ÙŠØ¯Ø© ÙˆØªØ®Ø²ÙŠÙ†Ù‡Ø§ Ù…Ø¤Ù‚ØªÙ‹Ø§ ÙÙŠ IndexedDB.");
          const response = await fetch("https://abdo12249.github.io/1/test1/animes.json");
          if (!response.ok) throw new Error("âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ animes.json");

          const data = await response.json();
          const animeList = Object.entries(data).map(([id, anime]) => ({
            id,
            ...anime
          }));

          // Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ IndexedDB
          const cacheObject = {
            animes: animeList,
            timestamp: Date.now()
          };
          await writeToIndexedDB(CACHE_KEY, cacheObject);
          console.log("âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ ÙÙŠ IndexedDB.");

          allAnimes = animeList;
        }

        displayFilteredAnime(allAnimes);
      } catch (error) {
        console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª Ø£Ùˆ IndexedDB:", error);
        // ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©ØŒ Ø­Ø§ÙˆÙ„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ù† IndexedDB ÙƒØ®ÙŠØ§Ø± Ø§Ø­ØªÙŠØ§Ø·ÙŠ (Ø­ØªÙ‰ Ù„Ùˆ Ø§Ù†ØªÙ‡Øª Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©)
        try {
          const cachedData = await readFromIndexedDB(CACHE_KEY);
          if (cachedData && cachedData.animes) {
            allAnimes = cachedData.animes;
            displayFilteredAnime(allAnimes);
            console.log("âš ï¸ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ Ù…Ù† IndexedDB Ø¨Ø³Ø¨Ø¨ ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©.");
          } else {
            console.error("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ IndexedDB. Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¹Ø±Ø¶ Ø£ÙŠ Ø£Ù†Ù…ÙŠØ§Øª.");
            // ÙŠÙ…ÙƒÙ†Ùƒ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ù… ØªØªÙˆÙØ± Ø¨ÙŠØ§Ù†Ø§Øª
          }
        } catch (dbError) {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© IndexedDB Ø¨Ø¹Ø¯ ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨:", dbError);
        }
      } finally {
        hideLoading(); // Ø¥Ø®ÙØ§Ø¡ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
      }
    }

    function adjustPath(path) {
      // Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªØ¹Ø¯Ù„ Ø§Ù„Ù…Ø³Ø§Ø± Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ.
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØµÙˆØ±Ùƒ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø£Ùˆ Ù…Ø³Ø§Ø± Ù†Ø³Ø¨ÙŠ Ù…Ø®ØªÙ„ÙØŒ ÙÙ‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§.
      if (path.startsWith('../')) {
        return path.replace('../', '../../');
      }
      return path;
    }

    function displayFilteredAnime(animeList) {
      const animeGrid = document.getElementById("animeGrid");
      animeGrid.innerHTML = "";

      animeList.forEach(anime => {
        const tags = anime.tags || anime.categories || [];
        if (!category || tags.includes(category)) {
          const link = `../../test1/Anime Page Dynamic.html?id=${anime.id}`;

          const card = document.createElement("div");
          card.className = "anime-card";

          card.innerHTML = `
            <a href="${link}" style="text-decoration: none; color: inherit;">
              <div class="anime-image">
                <img src="${adjustPath(anime.image)}" alt="${anime.title}" loading="lazy" />
              </div>
              <div class="anime-info">
                <h3>${anime.title}</h3>
                <p>${anime.description || ''}</p>
                <div class="anime-meta">
                  <span><strong>Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª:</strong> ${tags.join(', ')}</span>
                  <span><strong>Ø§Ù„Ù…ÙˆØ³Ù…:</strong> ${anime.season || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}</span>
                  <span><strong>Ø§Ù„Ù…Ø¯Ø©:</strong> ${anime.duration || 'ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©'}</span>
                  <span><strong>Ø§Ù„Ø­Ø§Ù„Ø©:</strong> ${anime.status || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}</span>
                  <span class="watch-button">Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø¢Ù†</span>
                </div>
              </div>
            </a>
          `;

          animeGrid.appendChild(card);
        }
      });

      // Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø§Ù‚Ø¨ Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠ Ù„Ù„ØµÙˆØ± Ø¨Ø¹Ø¯ Ø¹Ø±Ø¶ Ø§Ù„ØµÙØ­Ø©
      const lazyImages = document.querySelectorAll('#animeGrid img[loading="lazy"]');
      if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              img.classList.add('loaded');
              observer.unobserve(img);
            }
          });
        });
        lazyImages.forEach(img => observer.observe(img));
      } else {
        lazyImages.forEach(img => img.classList.add('loaded'));
      }
    }

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª Ø¹Ù†Ø¯ ÙØªØ­ Ø§Ù„ØµÙØ­Ø©
    loadAnimes();
  </script>

  <script>
    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ
    fetch('../../navbar.html')
      .then(response => response.text())
      .then(data => document.getElementById('navbar-container').innerHTML = data)
      .catch(error => console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ:', error));
  </script>
</body>
</html>
