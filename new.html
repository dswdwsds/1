<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ØªØµÙ†ÙŠÙØ§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ</title>
  <link rel="stylesheet" href="../../CSS/style.css" />
  <link rel="icon" href="https://abdo12249.github.io/1/navbar/favicon.ico" type="image/x-icon" />
  <style>
    /* Ø£Ù†Ù…Ø§Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠ */
    img[loading="lazy"] {
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    img[loading="lazy"].loaded {
      opacity: 1;
    }

    /* Ø£Ù†Ù…Ø§Ø· Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: white;
      font-size: 1.5rem;
      flex-direction: column;
    }
    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #fff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙÙ„Ø§ØªØ± */
    #filters {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 20px;
      padding: 15px;
      background-color: #2a2a2a;
      border-radius: 8px;
      justify-content: center;
      align-items: center;
    }
    #filters label {
      color: white;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #filters select, #filters button {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background-color: #333;
      color: white;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.3s ease;
    }
    #filters select:hover, #filters button:hover {
      background-color: #444;
    }
    #filters button.watch-button {
      background-color: var(--primary-color, #ef4444);
    }
    #filters button.watch-button:hover {
      background-color: #b91c1c;
    }

    /* Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø´Ø¨ÙƒØ© (grid) Ù„Ù„Ø£Ù†Ù…ÙŠ */
    .anime-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 20px;
      padding: 20px;
      justify-content: center;
    }

    /* Ø£Ù†Ù…Ø§Ø· Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø£Ù†Ù…ÙŠ */
    .anime-card {
      background-color: #2a2a2a;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s ease-in-out;
      display: flex;
      flex-direction: column;
      text-align: center;
    }

    .anime-card:hover {
      transform: translateY(-5px);
    }

    .anime-image {
      width: 100%;
      height: 200px; /* Ø§Ø±ØªÙØ§Ø¹ Ø«Ø§Ø¨Øª Ù„Ù„ØµÙˆØ± */
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .anime-image img {
      width: 100%;
      height: 100%;
      object-fit: cover; /* Ù„Ø¶Ù…Ø§Ù† ØªØºØ·ÙŠØ© Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ù…Ø³Ø§Ø­Ø© Ø¯ÙˆÙ† ØªØ´ÙˆÙ‡ */
      display: block;
    }

    .anime-info {
      padding: 10px;
      color: white;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .anime-info h3 {
      font-size: 1.1rem;
      margin-top: 0;
      margin-bottom: 5px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .anime-meta {
      font-size: 0.9rem;
      color: #bbb;
      margin-bottom: 10px;
      /* Ø¬Ø¹Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¯Ø§Ø®Ù„ anime-meta ÙŠØ³ØªØ®Ø¯Ù… flexbox Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø¹Ù…ÙˆØ¯ÙŠØ§Ù‹ */
      display: flex;
      flex-direction: column;
      align-items: center; /* ØªÙˆØ³ÙŠØ· Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø£ÙÙ‚ÙŠØ§Ù‹ */
    }

    .anime-meta span {
      display: block; /* Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† ÙƒÙ„ span ÙŠØ£Ø®Ø° Ø³Ø·Ø±Ù‹Ø§ Ø¬Ø¯ÙŠØ¯Ù‹Ø§ */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%; /* Ù„Ø¬Ø¹Ù„ Ø§Ù„Ù€ span ÙŠØ£Ø®Ø° Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„ÙƒØ§Ù…Ù„ */
      text-align: center; /* ØªÙˆØ³ÙŠØ· Ø§Ù„Ù†Øµ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù€ span */
    }

    .anime-info .watch-button {
      display: inline-block;
      padding: 6px 10px;
      background-color: var(--primary-color, #ef4444);
      color: white;
      text-decoration: none;
      border-radius: 4px;
      transition: background-color 0.3s ease;
      margin-top: 10px; /* Ù„Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø§ÙØ© ÙÙˆÙ‚ Ø§Ù„Ø²Ø± */
    }

    .anime-info .watch-button:hover {
      background-color: #b91c1c;
    }

    /* Ø£Ù†Ù…Ø§Ø· Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØµÙØ­Ø§Øª */
    #pagination button {
      padding: 8px 15px;
      background-color: var(--primary-color, #ef4444);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      margin: 0 5px;
      transition: background-color 0.3s ease;
    }
    #pagination button:hover {
      background-color: #b91c1c;
    }
    #pagination button.active {
      background-color: #b91c1c;
      font-weight: bold;
    }
    #pagination span {
      color: #888;
      margin: 0 5px;
    }
  </style>
</head>
<body>
  <div id="navbar-container"></div>

  <main>
    <div class="section-header">
      <h1>ØªØµÙ†ÙŠÙØ§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ</h1>
      <!-- Ø²Ø± ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª -->
      <button onclick="refreshData()" class="watch-button">ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
    </div>

    <!-- ÙÙ„Ø§ØªØ± Ø§Ù„Ø£Ù†Ù…ÙŠ -->
    <div id="filters">
      <label>
        Ø§Ù„ØªØµÙ†ÙŠÙ:
        <select id="categorySelect" class="watch-button" onchange="applyFilters()">
          <option value="all">Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙ„</option>
        </select>
      </label>

      <label>
        Ø§Ù„Ù†ÙˆØ¹:
        <select id="typeSelect" class="watch-button" onchange="applyFilters()">
          <option value="all">Ø§Ù„ÙƒÙ„</option>
        </select>
      </label>

      <label>
        Ø§Ù„Ø­Ø§Ù„Ø©:
        <select id="statusSelect" class="watch-button" onchange="applyFilters()">
          <option value="all">Ø§Ù„ÙƒÙ„</option>
        </select>
      </label>

      <label>
        Ø§Ù„Ù…ÙˆØ³Ù…:
        <select id="seasonSelect" class="watch-button" onchange="applyFilters()">
          <option value="all">Ø§Ù„ÙƒÙ„</option>
        </select>
      </label>

      <button onclick="resetFilters()" class="watch-button">Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ÙÙ„Ø§ØªØ±</button>
    </div>

    <!-- Ø´Ø¨ÙƒØ© Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª -->
    <div class="anime-grid" id="animeGrid"></div>

    <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØµÙØ­Ø§Øª -->
    <div id="pagination" style="text-align: center; margin-top: 20px;"></div>
  </main>

  <!-- Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ...</span>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    let currentPage = parseInt(urlParams.get("page")) || 1;
    const itemsPerPage = 30;
    let allAnimes = []; // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª Ø¨Ø¹Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±
    let originalAnimes = []; // Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªÙ… Ø¬Ù„Ø¨Ù‡Ø§

    // Ø«ÙˆØ§Ø¨Øª IndexedDB
    const DB_NAME = 'AnimeCategoriesDB'; // Ø§Ø³Ù… Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø®ØªÙ„ÙØ© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¹Ø§Ø±Ø¶
    const DB_VERSION = 1;
    const STORE_NAME = 'animeDataCache';
    const CACHE_KEY = 'cachedAnimeCategories';

    let db; // Ù…ØªØºÙŠØ± Ù„Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ù†Ø³Ø®Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª IndexedDB

    // Ø¯Ø§Ù„Ø© Ù„ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª IndexedDB
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME);
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };

        request.onerror = (event) => {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† IndexedDB
    async function readFromIndexedDB(key) {
      if (!db) {
        await openDatabase();
      }
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(key);

        request.onsuccess = (event) => {
          resolve(event.target.result);
        };

        request.onerror = (event) => {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ IndexedDB
    async function writeToIndexedDB(key, data) {
      if (!db) {
        await openDatabase();
      }
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(data, key);

        request.onsuccess = () => {
          resolve();
        };

        request.onerror = (event) => {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ÙƒØªØ§Ø¨Ø© IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† IndexedDB
    async function clearIndexedDB(key) {
      if (!db) {
        await openDatabase();
      }
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(key);

        request.onsuccess = () => {
          console.log(`âœ… ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† IndexedDB Ù„Ù„Ù…ÙØªØ§Ø­: ${key}`);
          resolve();
        };

        request.onerror = (event) => {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø³Ø­ IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
    function showLoading() {
      document.getElementById('loadingOverlay').style.display = 'flex';
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø®ÙØ§Ø¡ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
    function hideLoading() {
      document.getElementById('loadingOverlay').style.display = 'none';
    }

    function updatePageInURL(page) {
      // ØªØ¬Ù†Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… pushState ÙÙŠ Ø¨ÙŠØ¦Ø§Øª Ù…Ø«Ù„ blob: URLs Ù„ØªØ¬Ù†Ø¨ SecurityError
      if (window.location.protocol !== 'blob:') {
        const url = new URL(window.location);
        url.searchParams.set("page", page);
        // ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù‚Ø¨Ù„ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‚ÙŠÙ…ØªÙ‡Ø§
        const categorySelect = document.getElementById("categorySelect");
        const typeSelect = document.getElementById("typeSelect");
        const statusSelect = document.getElementById("statusSelect");
        const seasonSelect = document.getElementById("seasonSelect");

        if (categorySelect) url.searchParams.set("category", categorySelect.value);
        if (typeSelect) url.searchParams.set("type", typeSelect.value);
        if (statusSelect) url.searchParams.set("status", statusSelect.value);
        if (seasonSelect) url.searchParams.set("season", seasonSelect.value);

        window.history.pushState({}, "", url);
      } else {
        console.warn("âš ï¸ ØªØ­Ø¯ÙŠØ« URL Ù…Ø¹Ø·Ù„ ÙÙŠ Ø¨ÙŠØ¦Ø© blob: URL Ù„ØªØ¬Ù†Ø¨ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø£Ù…Ø§Ù†.");
      }
    }

    async function loadAnimeData() {
      showLoading(); // Ø¥Ø¸Ù‡Ø§Ø± Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
      try {
        await openDatabase(); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙØªØ­ IndexedDB

        let shouldFetchNewData = false;
        let serverLastModified = null;

        try {
          // Ø§Ù„Ø®Ø·ÙˆØ© 1: Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± ØªØ¹Ø¯ÙŠÙ„ Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø·Ù„Ø¨ HEAD
          const headResponse = await fetch("https://abdo12249.github.io/1/test1/animes.json", { method: 'HEAD' });
          if (headResponse.ok) {
            serverLastModified = headResponse.headers.get('Last-Modified');
            console.log("âœ… ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± ØªØ¹Ø¯ÙŠÙ„ Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù…:", serverLastModified);
          } else {
            console.warn("âš ï¸ ÙØ´Ù„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± ØªØ¹Ø¯ÙŠÙ„ Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù…ØŒ Ø³Ù†ØªØ§Ø¨Ø¹ Ø¨Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ ØªØ®Ø²ÙŠÙ† Ù…Ø¤Ù‚Øª Ø£Ùˆ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØªÙ‡.");
          }
        } catch (headError) {
          console.warn("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± ØªØ¹Ø¯ÙŠÙ„ (HEAD):", headError);
          // Ø¥Ø°Ø§ ÙØ´Ù„ Ø·Ù„Ø¨ HEADØŒ Ø³Ù†ÙØªØ±Ø¶ Ø£Ù†Ù†Ø§ Ø¨Ø­Ø§Ø¬Ø© Ù„Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
        }

        const cachedObject = await readFromIndexedDB(CACHE_KEY);

        if (cachedObject && cachedObject.animes) {
          // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ù‚Ø§Ø±Ù† Ø§Ù„ØªÙˆØ§Ø±ÙŠØ®
          const cachedTimestamp = cachedObject.timestamp;
          const cachedDate = new Date(cachedTimestamp);

          if (serverLastModified) {
            const serverDate = new Date(serverLastModified);
            if (serverDate.getTime() > cachedDate.getTime()) {
              console.log("ğŸ”„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø®Ø§Ø¯Ù… Ø£Ø­Ø¯Ø« Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªÙ‹Ø§. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©.");
              shouldFetchNewData = true;
            } else {
              console.log("âœ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù…Ø­Ø¯Ø«Ø© Ù…Ø¹ Ø§Ù„Ø®Ø§Ø¯Ù…. Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø©.");
              allAnimes = cachedObject.animes;
              originalAnimes = [...allAnimes];
            }
          } else {
            // Ø¥Ø°Ø§ Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ serverLastModifiedØŒ Ø³Ù†Ù‚ÙˆÙ… Ø¨Ø§Ù„Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ
            console.warn("âš ï¸ ØªØ¹Ø°Ø± ØªØ­Ø¯ÙŠØ¯ ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± ØªØ¹Ø¯ÙŠÙ„ Ù„Ù„Ø®Ø§Ø¯Ù…. Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„ÙƒØ§Ù…Ù„.");
            shouldFetchNewData = true;
          }
        } else {
          // Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªÙ‹Ø§ØŒ Ù„Ø°Ø§ Ù†Ø­ØªØ§Ø¬ Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©
          console.log("ğŸ”„ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªÙ‹Ø§. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©.");
          shouldFetchNewData = true;
        }

        if (shouldFetchNewData) {
          console.log("ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ© ÙˆØªØ®Ø²ÙŠÙ†Ù‡Ø§ Ù…Ø¤Ù‚ØªÙ‹Ø§ ÙÙŠ IndexedDB.");
          const response = await fetch("https://abdo12249.github.io/1/test1/animes.json");
          if (!response.ok) throw new Error("âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ animes.json");

          const data = await response.json();
          const animeList = Object.entries(data).map(([id, anime]) => ({ id, ...anime }));

          // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø·Ø§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠ Ø¨Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠØŒ Ø£Ùˆ Ø¨ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± ØªØ¹Ø¯ÙŠÙ„ Ù„Ù„Ø®Ø§Ø¯Ù… Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ù‹Ø§ ÙˆÙ…ÙˆØ«ÙˆÙ‚Ù‹Ø§
          const newTimestamp = serverLastModified ? new Date(serverLastModified).getTime() : Date.now();

          const cacheObject = {
            animes: animeList,
            timestamp: newTimestamp
          };
          await writeToIndexedDB(CACHE_KEY, cacheObject);
          console.log("âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ IndexedDB.");

          allAnimes = animeList;
          originalAnimes = animeList;
        }

        generateFilterOptions();
        applyFilters(); // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ± ÙˆØ¹Ø±Ø¶ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
      } catch (error) {
        console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª Ø£Ùˆ IndexedDB:", error);
        // ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©ØŒ Ø­Ø§ÙˆÙ„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ù† IndexedDB ÙƒØ®ÙŠØ§Ø± Ø§Ø­ØªÙŠØ§Ø·ÙŠ
        try {
          const cachedData = await readFromIndexedDB(CACHE_KEY);
          if (cachedData && cachedData.animes) {
            allAnimes = cachedData.animes;
            originalAnimes = [...allAnimes];
            generateFilterOptions();
            applyFilters();
            console.log("âš ï¸ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ Ù…Ù† IndexedDB Ø¨Ø³Ø¨Ø¨ ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ© (Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø¯ÙŠÙ…Ø©).");
          } else {
            console.error("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ IndexedDB. Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¹Ø±Ø¶ Ø£ÙŠ Ø£Ù†Ù…ÙŠØ§Øª.");
            // ÙŠÙ…ÙƒÙ†Ùƒ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ù… ØªØªÙˆÙØ± Ø¨ÙŠØ§Ù†Ø§Øª
          }
        } catch (dbError) {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© IndexedDB Ø¨Ø¹Ø¯ ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨:", dbError);
        }
      } finally {
        hideLoading(); // Ø¥Ø®ÙØ§Ø¡ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
      }
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙŠØ¯ÙˆÙŠØ§Ù‹
    async function refreshData() {
      showLoading();
      await clearIndexedDB(CACHE_KEY); // Ù…Ø³Ø­ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
      await loadAnimeData(); // Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©
      hideLoading();
    }

    function adjustPath(path) {
      // Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªØ¹Ø¯Ù„ Ø§Ù„Ù…Ø³Ø§Ø± Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ.
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØµÙˆØ±Ùƒ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø£Ùˆ Ù…Ø³Ø§Ø± Ù†Ø³Ø¨ÙŠ Ù…Ø®ØªÙ„ÙØŒ ÙÙ‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§.
      return path.startsWith('../') ? path.replace('../', '../../') : path;
    }

    function displayAnime(anime) {
      const card = document.createElement('div');
      card.className = 'anime-card';
      const categories = anime.tags || anime.categories || [];

      card.innerHTML = `
        <a href="../../test1/Anime Page Dynamic.html?id=${anime.id}" style="text-decoration: none; color: inherit;">
          <div class="anime-image">
            <img src="${adjustPath(anime.image)}" alt="${anime.title}" loading="lazy" />
          </div>
          <div class="anime-info">
            <h3>${anime.title}</h3>
            <p>${anime.description || ''}</p>
            <div class="anime-meta">
              <span><strong>Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª:</strong> ${categories.join(', ')}</span>
              <span><strong>Ø§Ù„Ù†ÙˆØ¹:</strong> ${anime.type || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}</span>
              <span><strong>Ø§Ù„Ù…ÙˆØ³Ù…:</strong> ${anime.season || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}</span>
              <span><strong>Ø§Ù„Ù…Ø¯Ø©:</strong> ${anime.duration || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©'}</span>
              <span><strong>Ø§Ù„Ø­Ø§Ù„Ø©:</strong> ${anime.status || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}</span>
              <span class="watch-button" style="display: block; margin-top: 10px;">Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø¢Ù†</span>
            </div>
          </div>
        </a>
      `;
      return card;
    }

    function showPage(page) {
      const animeGrid = document.getElementById('animeGrid');
      animeGrid.innerHTML = "";

      const startIndex = (page - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const currentItems = allAnimes.slice(startIndex, endIndex);

      currentItems.forEach(anime => {
        const card = displayAnime(anime);
        animeGrid.appendChild(card);
      });

      // Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø§Ù‚Ø¨ Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠ Ù„Ù„ØµÙˆØ± Ø¨Ø¹Ø¯ Ø¹Ø±Ø¶ Ø§Ù„ØµÙØ­Ø©
      const lazyImages = document.querySelectorAll('#animeGrid img[loading="lazy"]');
      if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              img.classList.add('loaded');
              observer.unobserve(img);
            }
          });
        });
        lazyImages.forEach(img => observer.observe(img));
      } else {
        lazyImages.forEach(img => img.classList.add('loaded'));
      }
    }

    function createPagination() {
      const pagination = document.getElementById('pagination');
      pagination.innerHTML = "";

      const totalPages = Math.ceil(allAnimes.length / itemsPerPage);
      const maxVisiblePages = 5;

      if (currentPage > 1) {
        const prevBtn = document.createElement('button');
        prevBtn.textContent = "â† Ø§Ù„Ø³Ø§Ø¨Ù‚";
        prevBtn.className = "watch-button";
        prevBtn.onclick = () => {
          currentPage--;
          updatePageInURL(currentPage);
          showPage(currentPage);
          createPagination();
        };
        pagination.appendChild(prevBtn);
      }

      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
      if (endPage - startPage < maxVisiblePages - 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }

      for (let i = startPage; i <= endPage; i++) {
        const button = document.createElement('button');
        button.textContent = i;
        button.className = "watch-button";
        if (i === currentPage) button.classList.add("active");
        button.onclick = () => {
          currentPage = i;
          updatePageInURL(currentPage);
          showPage(currentPage);
          createPagination();
        };
        pagination.appendChild(button);
      }

      if (endPage < totalPages) {
        const dots = document.createElement('span');
        dots.textContent = "...";
        dots.style.margin = "0 10px";
        pagination.appendChild(dots);

        const lastBtn = document.createElement('button');
        lastBtn.textContent = totalPages;
        lastBtn.className = "watch-button";
        lastBtn.onclick = () => {
          currentPage = totalPages;
          updatePageInURL(currentPage);
          showPage(currentPage);
          createPagination();
        };
        pagination.appendChild(lastBtn);
      }

      if (currentPage < totalPages) {
        const nextBtn = document.createElement('button');
        nextBtn.textContent = "Ø§Ù„ØªØ§Ù„ÙŠ â†’";
        nextBtn.className = "watch-button";
        nextBtn.onclick = () => {
          currentPage++;
          updatePageInURL(currentPage);
          showPage(currentPage);
          createPagination();
        };
        pagination.appendChild(nextBtn);
      }
    }

    function generateFilterOptions() {
      const categorySet = new Set();
      const typeSet = new Set();
      const statusSet = new Set();
      const seasonMap = new Map();

      originalAnimes.forEach(anime => {
        (anime.tags || anime.categories || []).forEach(tag => categorySet.add(tag));
        if (anime.type) typeSet.add(anime.type);
        if (anime.status) statusSet.add(anime.status);
        if (anime.season) seasonMap.set(anime.season.trim(), true);
      });

      const seasonOrder = { "Ø´ØªØ§Ø¡": 1, "Ø±Ø¨ÙŠØ¹": 2, "ØµÙŠÙ": 3, "Ø®Ø±ÙŠÙ": 4 };
      const sortedSeasons = [...seasonMap.keys()]
        .map(season => {
          const parts = season.split(" ");
          return { season, year: parseInt(parts[1]), order: seasonOrder[parts[0]] || 99 };
        })
        .sort((a, b) => a.year - b.year || a.order - b.order)
        .map(item => item.season);

      fillSelect("categorySelect", categorySet);
      fillSelect("typeSelect", typeSet);
      fillSelect("statusSelect", statusSet);
      fillSelect("seasonSelect", sortedSeasons);

      setFiltersFromURL();
    }

    function fillSelect(id, values) {
      const select = document.getElementById(id);
      // Ù…Ø³Ø­ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨Ø§Ø³ØªØ«Ù†Ø§Ø¡ "Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙ„" Ø£Ùˆ "Ø§Ù„ÙƒÙ„"
      while (select.children.length > 1) {
        select.removeChild(select.lastChild);
      }
      values.forEach(value => {
        const option = document.createElement("option");
        option.value = value;
        option.textContent = value;
        select.appendChild(option);
      });
    }

    function setFiltersFromURL() {
      const category = urlParams.get("category");
      const type = urlParams.get("type");
      const status = urlParams.get("status");
      const season = urlParams.get("season");

      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù‚Ø¨Ù„ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚ÙŠÙ…Ø©
      const categorySelect = document.getElementById("categorySelect");
      const typeSelect = document.getElementById("typeSelect");
      const statusSelect = document.getElementById("statusSelect");
      const seasonSelect = document.getElementById("seasonSelect");

      if (category && categorySelect && Array.from(categorySelect.options).some(opt => opt.value === category)) categorySelect.value = category;
      if (type && typeSelect && Array.from(typeSelect.options).some(opt => opt.value === type)) typeSelect.value = type;
      if (status && statusSelect && Array.from(statusSelect.options).some(opt => opt.value === status)) statusSelect.value = status;
      if (season && seasonSelect && Array.from(seasonSelect.options).some(opt => opt.value === season)) seasonSelect.value = season;
    }

    function applyFilters() {
      const selectedCategory = document.getElementById("categorySelect").value;
      const selectedType = document.getElementById("typeSelect").value;
      const selectedStatus = document.getElementById("statusSelect").value;
      const selectedSeason = document.getElementById("seasonSelect").value;

      allAnimes = originalAnimes.filter(anime => {
        const tags = anime.tags || anime.categories || [];
        const categoryMatch = selectedCategory === "all" || tags.includes(selectedCategory);
        const typeMatch = selectedType === "all" || anime.type === selectedType;
        const statusMatch = selectedStatus === "all" || anime.status === selectedStatus;
        const seasonMatch = selectedSeason === "all" || anime.season === selectedSeason;
        return categoryMatch && typeMatch && statusMatch && seasonMatch;
      });

      currentPage = parseInt(urlParams.get("page")) || 1; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ù† URL Ø¨Ø¹Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±
      showPage(currentPage);
      createPagination();
      updatePageInURL(currentPage); // ØªØ­Ø¯ÙŠØ« URL Ø¨Ø¹Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±
    }

    function resetFilters() {
      document.getElementById("categorySelect").value = "all";
      document.getElementById("typeSelect").value = "all";
      document.getElementById("statusSelect").value = "all";
      document.getElementById("seasonSelect").value = "all";
      currentPage = 1;
      applyFilters(); // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ± Ø¨Ø¹Ø¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·
    }

    // Ø¨Ø¯Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
    loadAnimeData();
  </script>

  <script>
    // ØªØ­Ù…ÙŠÙ„ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ†Ù‚Ù„ (navbar)
    fetch('../../navbar.html')
      .then(response => response.text())
      .then(data => document.getElementById('navbar-container').innerHTML = data)
      .catch(error => console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ:', error));
  </script>
</body>
</html>

